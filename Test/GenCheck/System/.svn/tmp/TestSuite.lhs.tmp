A test suite consists of instructions for constructing a set of test cases.
This module contains functions to build test suites from generators,
using different strategies to allocate the number of test cases for each rank.

\begin{code}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FlexibleContexts #-}

module Test.GenCheck.System.TestSuite 
  ( GenInstruct
  , TestSuite
  , MapRankSuite
  , genSuite
  , testSuite
  , baseSuite
  , stdSuite
  , deepSuite
  , suiteMerge
  ) where

import Prelude hiding (map)
import qualified Prelude(map)
import Data.Map (Map)
import Data.Monoid(Monoid)
import System.Random(StdGen)

import Test.GenCheck.Base.Base (Rank, Count)
import Test.GenCheck.Generator.Generator (Generator, genTake, StandardGens, stdGenList)
import Test.GenCheck.Base.LabelledPartition as Partition (LabelledPartition(..))

\end{code}

<<<<<<< .mine
The containers for the test cases must be instances of the LabelledPartition
class.  This class provides labelled partitions for the test cases (e.g.
Data.Map), but also supports merging of the containers.  Multiple component
test suites can be merged into a single test suite using suiteMerge.

\begin{code}
type TestSuite c k v a = c k (v a) 
  -- (LabelledPartition c k v, Monoid (v a), Ord k)

suiteMerge :: (LabelledPartition c k v, Monoid (v a), Ord k) => 
                  [TestSuite c k v a] -> TestSuite c k v a
suiteMerge = foldl1 Partition.merge
\end{code}

=======
>>>>>>> .r1099
testSuite, genSuite and genPart build test suites from generator(s) given a
list of ranks and the number of values desired at that rank.  (called
GenInstruct).  This provides a simple API for building test suites.

\begin{code}
type MapRankSuite a = TestSuite Map Rank [] a   -- = Map Rank [a]

type GenInstruct = [(Rank, Count)]

testSuite :: [Generator a] -> [GenInstruct] -> MapRankSuite a
testSuite gs rcs = suiteMerge $ zipWith genSuite gs rcs

genSuite :: Generator a -> GenInstruct -> MapRankSuite a
genSuite g rcs = suiteMerge $ Prelude.map (genPart g) rcs

genPart :: Generator a -> (Rank, Count) -> MapRankSuite a
genPart g (r,n) = Partition.new r $ genTake g r n
\end{code}

baseSuite is used for base type generators; all values are of rank 1.

\begin{code}
baseSuite :: StandardGens a -> StdGen -> Count -> MapRankSuite a
baseSuite stdg s n = 
  let nr = (n `div` 4) + 1
      gis =  [(1, nr)]
      uni = fromInteger $ max (nr `div` 4 + 1) 3
  in  testSuite (stdGenList stdg uni s) (repeat gis)
\end{code}

stdSuite uses all of the standard generators to create a good heuristic
default approach for testing across multiple ranks.

\gordon{for now, this is the same as the deepSuite, just until I get to it???}

\begin{code}
stdSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
stdSuite stdg s rmax n = 
  let nr = ((n `div` (toInteger rmax) + 1) `div` 4) + 1
      gis =  [(r, nr) | r <- [1..rmax]]
      uni = fromInteger $ max (nr `div` 4 + 1) 3
  in  testSuite (stdGenList stdg uni s) (repeat gis)
\end{code}

deepSuite performs a small number of tests over each rank up to a maximum size,
by dividing the number of tests evenly over the total number of ranks,
using the same rank and count instructions for each generator.

\begin{code}
deepSuite :: StandardGens a -> StdGen -> Rank -> Count -> MapRankSuite a
deepSuite stdg s rmax n = 
  let nr = ((n `div` (toInteger rmax) + 1) `div` 4) + 1
      gis =  [(r, nr) | r <- [1..rmax]]
      uni = fromInteger $ max (nr `div` 4 + 1) 3
  in  testSuite (stdGenList stdg uni s) (repeat gis)
\end{code}

The containers for the test cases must be instances of the LabelledPartition class.  
This class provides labelled partitions for the test cases (e.g. Data.Map), 
but also supports merging of the containers.  Multiple component test suites
can be merged into a single test suite using suiteMerge.

\begin{code}
type TestSuite c k v a = c k (v a) -- (LabelledPartition c k v, Monoid (v a), Ord k)

suiteMerge :: (LabelledPartition c k v, Monoid (v a), Ord k) => 
                  [TestSuite c k v a] -> TestSuite c k v a
suiteMerge = foldl1 Partition.merge

\end{code}

<<<<<<< .mine
--\end{code}

Automatic test case generators in GenCheck partition the test domain with a
rank (or size), where the rank is a natural number.  When generating a test
suite with a specified number of test cases, it is important to specify, or
allocate, the number of cases to be drawn from each of the ranks, up to a
maximum rank.

singleGenAll exhaustively generates all of the test cases from a single
generator, within a range of ranks, up to the requested number of cases,
grouped by rank.  If the generator produces fewer test cases than were
requested, the suite will have fewer test caes than requested.

--\begin{code}
singleGenAll :: (LabelledPartition c Rank []) => 
    Generator a -> (Rank,Rank) -> Count -> TestSuite c Rank [] a
singleGenAll g (rl,ru) n = Partition.fromList $ rankedTake g n [rl..ru]
--\end{code}

Although the meaning of the rank is generator dependent, the intention is that
the smaller ranks represent ``smaller'' or simpler test cases.  There are
typically a smaller number of simple test cases.  and they are typically very
important to test, although this depends on the choice of ranking and domain.

The following are allocation strategies for selecting test cases from a single
generator based on a range of ranks.  They use linear or polynomial functions
to cap allocations of test cases to each rank as a heuristic method of sampling
test values.  The test cases are partitioned and labelled by rank in the suite.

\begin{description}
\item[singleGenEq] allocates equal number of test cases to all ranks in the
range
\item[singleGenLinear] linearly increasing number of test cases to ranks in a
range
\item[singleGenExp] exponentially increases number of test cases along ranks in
a range, given an arbitrary base (e.g. 2 or 3) to control rate of increase
\end{description}

Round off errors in each of these allocations means that the number of test
cases may not be exactly as requested.

-- \begin{code}
type RankedSuite c v a = c Rank (v a) 
    -- must be an instance of LabelledPartition c k v
type SingleRankGenAlloc c v a = 
    Generator a -> (Rank,Rank) -> Count -> RankedSuite c v a

singleGenEq :: (LabelledPartition c Rank v, Monoid (v a)) => 
    Generator a -> (Rank, Rank) -> Count -> RankedSuite c v a
singleGenEq g (rl,ru) n = 
  let rng = ru - rl
      cnt = n `div` (toInteger rng) + (1::Integer)
      xs = Prelude.map (\x -> (x, takeL cnt $ g x)) [rl..ru]
  in  Partition.fromList xs

singleGenLinear :: (LabelledPartition c Rank v, Monoid (v a)) => 
    Generator a -> (Rank, Rank) -> Count -> RankedSuite c v a
singleGenLinear g (rl,ru) n = 
  let rng = ru - rl
      cnt = n `div` (toInteger (rng*(rng - 1))) + (1::Integer)
      xs = Prelude.map (\x -> (x, takeL (cnt*(toInteger x)) $ g x)) [rl..ru]
  in  Partition.fromList xs

singleGenExp :: (LabelledPartition c Rank v, Monoid (v a)) => 
    Int -> Generator a -> (Rank,Rank) -> Count -> RankedSuite c v a
singleGenExp b g (rl, ru) n = 
  let rn = b^(ru+1) - 1 -- number of "boxes" of test cases
      bsz = (n `div` (toInteger rn)) + 1
      xs = Prelude.map (\r -> (r, takeL (bsz * (toInteger b^(r + rl))) (g r))) [rl..ru] 
  in if ru < rl then Partition.empty
     else Partition.fromList xs

-- \end{code}
=======
>>>>>>> .r1099
