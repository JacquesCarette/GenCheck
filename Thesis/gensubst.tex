%\section{Recursive Generator Construction}\label{sub:gensubst}
% for polymorphism, ranked composition vs. unranked substitution; 
% ranking based on substitution set size (as a complexity measure)

Composite structures can be generated by generating populated inner data structures
and then substituting them into the outside shape,
treating them as atomic values.
Alternatively,
the composite shapes may be constructed as if they were a single constructor,
and then substituting the data elements as above.
For example,
assume a type context includes both 
polymorphic lists ($L(\alpha)$) and binary trees ($B(\beta)$).
A property could be defined over lists of trees ($L (B(\beta)) $,
and the test cases would be lists of trees of a specific type 
(say |Int|, without loss of generality).
The property domain could be considered lists of binary integer trees,
or polymorphic ``tree lists'' $(L \scomp B)(\beta))$
with a substitution of integer element types.
These two views of the resulting ``shape'' of the construction
do not alter the evaluation of the subsequent expressions,
but do provide alternative ways to establish a test selection strategy:
\begin{enumerate}
\item a sample of binary trees with  |Int| elements
and a sample of lists can be generated independently,
and then the binary trees can be substituted as elements into the lists
(generation with substitution);
\item a sample of binary tree lists can be generated,
and then populated with samples of the elements (|Int|s )
(composed generators with substitution);
\item the concrete type (integer binary tree lists) can be sampled as a single set of values,
by selecting a small number of allowable |Ints| for the test cases
(generator composition).
\end{enumerate}

\gordon{Picture of a substitution occurring with several substitution sets of base elements,
and beside it a composition such as a list of trees, followed by a substitution}

Although composition and substitution are actually the same operation,
in this thesis the terms will be differentiated slightly
depending on how the rank of the composed / substituted values are calculated.
Substitution will describe the case where 
a data structure is being populated with values of a fixed rank, 
generally a base type,
so elements can be treated as having a constant rank of 1 for substitution.
Composition will refer to the substitution of inner shapes into outer shapes,
where the rank of the composed structure is a combination of
the ranks of the outer and inner structures,
and the ``nodes'' of the inner shape elements become 
the nodes of the composite structure,
and can subsequently be populated using substitution.

The choice of how composite structures will be generated is primarily pragmatic
and depends on the nature of the properties being tested.
If the properties are perceived to be more sensitive to
the ``shape'' of the data structure,
such as a module that supports polymorphic height balanced trees, 
it might make more sense to focus the test selection on the structural components
and then just ensure a reasonable variety of elements are selected.
Other tests might be more sensitive to the arrangement of 
the element values within the structure,
so the test cases should be treated holistically.
These heuristics will be discussed throughout this chapter,
and the ability to generate test cases as independent shapes and elements
or as whole values will be presented as an important advantage of
the \GC framework for automated test case generation.


