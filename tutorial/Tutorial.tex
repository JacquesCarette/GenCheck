\section{Tutorial 1: The simplest case.}

\input {reverse/TestReverseList.lhs}

The examples in this module have properties over standard Haskell types, where
the default generators were already available.  How are test cases generated
when the module contains a new type?  How are the test cases chosen for
inclusion in the test suite, and how can that be controlled?  Surely there is
a better way to display the results?  These questions and more are answered
in the next part of the tutorial.  

\section{Tutorial 2: Testing with New Data Types}

The first tutorial covered testing properties over standard Haskell types.
Default test case generators were already supplied by GenCheck
as instances of the Testable class, but what about new data types?
In this tutorial, we explain how to use the type constructor definition and 
GenCheck enumeration combinators to construct the standard test generators
based on the type constructor definitions.

There are three steps in testing a module against 
a specification using the GenCheck framework:

\begin{enumerate}
\item define and code the properties that make up the specification
\item select the test system that provides the most appropriate
test scheduling and reporting schema for the current phase of the development
\item define the test suite for those properties,
including the test case generators for each.
\end{enumerate}

In the previous section the details of the test system
and test suite generation were hidden by the SimpleCheck API.
In this section, we look at each of these steps in detail 
and discuss how to generate new data types and customize test suites
for a particular set of properties.

For this tutorial, we'll look at a list zipper implementation,
taken from the ListZipper package (1.2.0.2).  Only snippets
of the code will be provided as the package is rather large
(see tutorial/list\_zipper/ListZipper.hs  for the module source).
The Zipper data type is

\begin{verbatim}

data Zipper a = Zip ![a] ![a] deriving (Eq,Show)

\end{verbatim}

where the ``current'' element or ``cursor'' is the head of the second list.
The specification for ListZipper includes empty, cursor, start, end, left, right, foldrz, foldlz, 
and many more functions.  The example below shows how to test (some)
of the specification for this module, with a focus on the generators for the new type.

\subsection{Specifications and Properties}
A GenCheck specification is the collection of properties
that any implementation of the specification must satisfy.
Properties are univariate Boolean valued Haskell functions;
this is not a restriction as the input value may be of an arbitrarily complicated type 
to support uncurried predicates. The GenCheck test programs accept 
a single property and test it over the defined suite of test cases.
Only one property is tested per call because different properties 
may have different input types or require different test suites
The specification module would normally be separate from the implementation,
but may include functions that test the properties using GenCheck.

\subsubsection{List Zipper Properties}

\input {list_zipper/PropListZip.lhs}

\subsection{Test Suites and Standard Generators}
The module System.TestSuite contains functions that assemble test suites 
from one or more test case generators. These suite builders take a collection of 
``standard'' generators and a set of ``generator instructions'', a list of rank, count pairs.  
The allocation of test cases to ranks through these instructions is called a ``test strategy'' 
and can be used independently of the type of data being generated, 
assuming that the standard generators are available for that type.

A GenCheck generator is any function from a rank (positive integer) to a list of values.
Generators may be finite or infinite, may include duplicates of the same value,
and may be missing values from the total population of the type.  Generators
can be manually coded or built from a GenCheck enumeration of the type using
a sampling strategy called an ``enumerative strategy''.  These strategies can be
applied to any data type that can be enumerated, i.e. ordered, and indexed by a finite rank.

The so called standard generators are just four different sampling strategies
that can be applied to an enumeration of the generated type.  These are:

\begin{description}
\item[exhaustive] {Produces all of the values of the specified rank in a sequence,}
\item[extreme]{Alternating lowest and highest values in the enumeration,}
\item[uniform]{Select the specified number elements at uniform intervals through the enumeration,}
\item[random]{Use the random generator to pick an infinite list of values.}
\end{description}

The basis for the test suites used by SimpleCheck test programs
are the standard generator set described above.
These are not the only valuable sampling strategies that could be used, but these were
selected as the ``standard'' generator strategies to be used by the GenCheck API.
A type is an instance of Testable if a set of standard generators is available for it;
these generators can be constructed for any type that has an Enumeration associated with it. 

A test suite is a collection of test cases selected from the ranks of one or more generators.
Each test suite uses a sampling ``strategy'' to decide which generators and
at what rank to select the test cases; this mix is called the test strategy.  
The SimpleCheck test strategies draw test cases from 
the four standard generator strategies to provide a good sampling 
of the test cases relative to the number of tests performed.
The strategies are heuristic of course, and the optimal composition of a test strategy
depends on the nature of the structures and properties  being tested,
so these provided test suite strategies are really just a starting point.
The TestSuite module contains the test suite building functions:

\begin{description}
\item[stdSuite] exhaustive testing for smaller structures, then the boundary elements
and a mix of uniformly and randomly selected values to the specified maximum rank 
\item[deepSuite] similar to standard but for ``narrow'' structures with fewer elements per rank
(i.e. a binary tree or list), so the exhaustive testing goes to a much higher rank
\item[baseSuite] a test suite for base types, where the rank is always 1
\end{description}

The System.SimpleCheck module test suites are test cases stored in 
a Haskell map (as in Data.Map) indexed by rank, called a MapRankSuite.

\subsubsection{Enumerating New Data Types}
A GenCheck enumeration is a way of ordering the values of a type,
and is used as the basis for the standard test case generators in GenCheck.
A generator can be any function that produces a list of values of the generated type.
Since the values are in a list, the generator must order those elements,
and the GenCheck enumerations are one way to provide a consistent index over the values.
Note that generators do not have to provide all of the possible values of the type,
nor is there a restriction against providing multiple instances of a value in any given list,
so the position of an element in a generator's output is not generally the same as an enumeration.

Haskell structure types can be recursively defined and therefore arbitrarily large,
even infinitely large with lazy evaluation.  To allow any sort of ordering of these infinite sets,
the values are first partitioned into finite subsets by the number of elements in the structure, 
which is called the rank of the structure.  The common sized elements in the subset 
are then ordered and indexed using a depth first, sum of products view of the values.
This allows most (any regularly recursive polynomial) structure type to be enumerated
using a two tiered (rank, integer index) pair.  Structure types that are enumerated are 
instances of the Enumerated class, which provides methods to count and select (construct)
values of the specified rank and index.

A base type, such as Int or Char, do not have a rank and are enumerated if there is a
single ordering over all of the elements of that type.  This is called a base enumeration (BaseEnum)
and is effectively the same as the Haskell Enum class; the GenCheck class is called EnumGC 
to highlight that it is an extension of Enum.

A generator may be constructed from an enumeration by mapping the selector method
over a sorted list of integer indices.  The GenCheck standard generators are created
by applying the four standard strategies - exhaustive, boundary (extreme), uniform and random -
over an enumeration of the type.  These sampling strategies abstract the test plan from
the concrete construction of particular instances of the test values, leaving the details
of the specified type being tested to the enumeration methods.  

Enumerations for standard Haskell data types such as list and tuples are provided.
For new data types, enumerations can be easily made using the enumeration combinators 
|eConst, eNode, eSum, eProd, etc.| in the Generator.Enumeration module.
These combinators simply mirror the structure of the type constructors
to produce the required enumerations, and can be constructed mechanically.

A pure structure enumeration / generator constructs structures that are over a constant value
(i.e. unit), so some method is required for substituting other values into the data nodes.
One approach is to define the structure over a particular kind of element,
and have the enumeration count all of those element types as distinct values of the structure.
From a testing perspective, this creates an unfortunate imbalance in the number of values
for any given size of structure vs. the relevance of the values in the structures' nodes.
For example, when testing a heap sort insert, it would be nice to exhaustively test
all \emph{shapes} of heaps up to a certain size, but not necessarily exhaustively test
all possible integer node values in each of those heap shapes.  A better solution 
is to create a structure generator and sample it using the appropriate strategies,
and then populate each of those shapes with one or more sets of values, 
also chosen from an appropriately sampling generator.  GenCheck supports this
kind of substitution at the generator level; a generator of structures $Foo a$ is
created by applying one of the substitution functions over a $Foo$ generator and an $a$ generator.
A collection of substitution functions is available in the Generator.Substitution module,
and provides the ability to populate each structure with one or more sets of elements,
using different strategies such as all permutations, all combinations, or just unique elements.
Substitution allows a great deal of control over the generation of complex data structures
by decoupling the sampling strategy of the structures, the elements, and their substitution;
this is one of the most important benefits of GenCheck over QuickCheck and SmallCheck.

\subsubsection{List Zipper Enumeration and Generators}

\input {list_zipper/ListZipper_GC.lhs}

Generators are created from enumerations and enumerative strategies
using Generator.enumGenerator for structure types and BaseGen.baseEnumGen for base types.
The standard generator set, and therefore the Testable instance, is built using stdEnumGens.

\subsection{The Testing Process}
Typically a GenCheck user would start with the default test suites
and only reporting failures during the development cycle.
Nearing completion, s/he would switch to the test programs 
that provide more control over the test suite generation,
and report all of the test cases in the results to ensure good coverage.


\subsubsection{Testing the List Zipper Module}
\input {list_zipper/TestListZipper.lhs}




%\section{Tutorial 3: Customizing the Test Programs}
%%
% Putting this on hold so Jacques can change the class definitions
%
%The objective of GenCheck is to provide a testing framework that
%scales in scope from a very simple QuickCheck like interface,
%through progressively more thorough test suites and reporting,
%during the course of the development towards production.
%The highly modular GenCheck API allows an arbitrarily deep level of control,
%with a commensurate level of complexity,
%supporting customization and new development as required.
%
%\subsection{Generalizing test data: Datum , Verdict, and LabelledPartition Classes}
%
%\begin{itemize}
%\item decouples test data, test result, meta data and storage of test suite / results
%\item define a structure for carrying data value as instance of Datum
%\item define a structure for carrying individual result as instance of Verdict
%\item define a structure for holding the collection of data and results as
%an instance of LabelledPartition
%\item arbitrary meta data about the test case or the evaluation of the result
%can then be carried through the GenCheck system
%\end{itemize}
%
%\subsubsection{Labelled Partitions}
%The test suites are test cases in the earlier tutorials are stored in
%a Haskell Map (as in Data.Map) indexed (or ``labelled'') by rank (called a MapRankSuite).
%This indexing mirrors the way the test cases are generated, namely by structure size,
%and is useful in unit testing structure manipulation functions such as reverse and fold,
%where the size of the structure is highly relevant, and is the only information 
%guaranteed to be available in general.
%
%Storing test results this way may or may not be meaningful in other situations,
%in particular where the values of an element play a key role in defining the outcome
%of the functions being tested.  In these cases, the tester will want to modify
%the partitioning to group (and label) test cases by some other useful value.
%The GenCheck framework allows test suite containers to be customized using
%a class called LabelledPartition that abstracts the interface required by the test programs.
%For example, a test over $Char$ might be grouped by the labels $ASCII$,
%$CONTROL$ and $Extended$ to help focus on unusual characters in a printing scheme.
%Multiple levels of partitioning can also be used, by embedding labelled partitions
%inside of labelled partitions, to allow a more granular level of test case analysis.
%
%The abstract structure of a labelled partition can also be leveraged to
%optimize the evaluation of tests by the test scheduling and evaluation.
%Testing is an excellent target for parallel execution, and very large tests
%might be carried out on multiple processors or even different systems.
%The structure of the labelled partition can be modified to support decentralized 
%test systems.
%
%\subsection{Generalizing Test Evaluation and Reporting}
%
%\begin{itemize}
%\item tests can be pure or monadic computations
%\item tests can be serialized or parallel
%\item might want to stop after some number of failures,
%or complete entire test suite
%\item the same test suite can be used in different modes
%\end{itemize}
%
%\subsection{The SimpleCheck System}
%The System.SimpleCheck module contains a simple set of test programs,
%each composed of a test suite building strategy and data structure, 
%an execution strategy, and a reporting strategy.  
%
%
